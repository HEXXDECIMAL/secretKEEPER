#!/bin/sh
#
# PROVIDE: secretkeeper
# REQUIRE: NETWORKING DAEMON
# KEYWORD: shutdown
#
# Add the following lines to /etc/rc.conf to enable secretkeeper:
#
#  secretkeeper=YES
#

$_rc_subr_loaded . /etc/rc.subr

name=secretkeeper
rcvar=$name

load_rc_config $name

: ${secretkeeper:=NO}
: ${secretkeeper_config:="/usr/pkg/etc/secretkeeper/config.toml"}
: ${secretkeeper_user:="root"}
: ${secretkeeper_flags:=""}
: ${secretkeeper_stop_timeout:=10}

pidfile="/var/run/${name}.pid"
command="/usr/local/bin/secretkeeper-agent"
command_args="--config ${secretkeeper_config} ${secretkeeper_flags}"

start_cmd="secretkeeper_start"
stop_cmd="secretkeeper_stop"
status_cmd="secretkeeper_status"

# Check if a PID is running
secretkeeper_pid_running()
{
    local pid="$1"
    if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
        return 0
    fi
    return 1
}

secretkeeper_start()
{
    # Check if already running
    if [ -f ${pidfile} ]; then
        local pid=$(cat ${pidfile} 2>/dev/null)
        if secretkeeper_pid_running "$pid"; then
            echo "${name} is already running as pid ${pid}."
            return 1
        fi
        # Stale PID file, remove it
        rm -f ${pidfile}
    fi

    echo "Starting ${name}."

    # NetBSD daemon(8) syntax
    /usr/sbin/daemon -p ${pidfile} ${command} ${command_args}

    # Verify the daemon actually started
    sleep 1
    if [ -f ${pidfile} ]; then
        local pid=$(cat ${pidfile} 2>/dev/null)
        if secretkeeper_pid_running "$pid"; then
            echo "${name} started as pid ${pid}."
            return 0
        fi
    fi

    echo "Failed to start ${name}. Check logs for details."
    rm -f ${pidfile}
    return 1
}

secretkeeper_stop()
{
    if [ ! -f ${pidfile} ]; then
        echo "${name} is not running (no PID file)."
        return 0
    fi

    local pid=$(cat ${pidfile} 2>/dev/null)
    if [ -z "$pid" ]; then
        echo "${name} is not running (empty PID file)."
        rm -f ${pidfile}
        return 0
    fi

    if ! secretkeeper_pid_running "$pid"; then
        echo "${name} is not running (stale PID file)."
        rm -f ${pidfile}
        return 0
    fi

    echo "Stopping ${name} (pid ${pid})."
    kill -TERM "$pid"

    # Wait for process to exit with timeout
    local waited=0
    while [ $waited -lt ${secretkeeper_stop_timeout} ]; do
        if ! secretkeeper_pid_running "$pid"; then
            echo "${name} stopped."
            rm -f ${pidfile}
            return 0
        fi
        sleep 1
        waited=$((waited + 1))
    done

    # Process didn't exit gracefully, force kill
    echo "Warning: ${name} did not stop gracefully, sending SIGKILL."
    kill -KILL "$pid" 2>/dev/null
    sleep 1

    if secretkeeper_pid_running "$pid"; then
        echo "Error: Failed to stop ${name}."
        return 1
    fi

    rm -f ${pidfile}
    echo "${name} stopped (forced)."
    return 0
}

secretkeeper_status()
{
    if [ ! -f ${pidfile} ]; then
        echo "${name} is not running (no PID file)."
        return 1
    fi

    local pid=$(cat ${pidfile} 2>/dev/null)
    if [ -z "$pid" ]; then
        echo "${name} is not running (empty PID file)."
        return 1
    fi

    if secretkeeper_pid_running "$pid"; then
        echo "${name} is running as pid ${pid}."
        return 0
    else
        echo "${name} is not running (stale PID file for pid ${pid})."
        return 1
    fi
}

run_rc_command "$1"
